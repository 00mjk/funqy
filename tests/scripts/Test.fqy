data Bool = F | T
data Dir3 = X | Y | Z

let (abc, qwe) = ((F, T), T)

fn equal = {
	(F, F) | (T, T) => T,
	_ => F,
}

fn (>>)(a, b) = b(a)
fn (<<)(a, b) = a(b)

fn (@)(s) = sup(s)
let (#) = measure

fn rx = {
	F => T,
	T => F,
}
let (!) = rx

assert @T : equal(T, T)
assert @T : !equal(F, T)

let (^) = sup
let (~) = phf

assert F ^ T : T ^ F
assert F ^ T : @(F ^ T)

fn id = {
	F => F,
	T => T,
}

fn rz = {
	F => F,
	T => ~T,
}

fn had = {
	F => F ^ T,
	T => F ^ ~T,
}

fn cnot(a, b) = extract a {
	F => (F, b),
	T => (T, !b),
}
let (*!) = cnot

fn bellgate(a, b) = had(a) *! b

fn bell = {
	(F, F) => (F, F) ^ (T, T),
	(F, T) => (F, T) ^ (T, F),
	(T, F) => (F, F) ^ ~(T, T),
	(T, T) => (F, T) ^ ~(T, F),
}
fn ibell = {
	(F, F) => (F, F) ^ (T, F),
	(F, T) => (F, T) ^ (T, T),
	(T, F) => (F, T) ^ ~(T, T),
	(T, T) => (F, F) ^ ~(T, F),
}

assert @F : had(had(F))

fn kron(a, b)(s) = extract s {
	(F, F) => (a(F), b(F)),
	(F, T) => (a(F), b(T)),
	(T, F) => (a(T), b(F)),
	(T, T) => (a(T), b(T)),
}
let (<>) = kron

fn encode(s, n) = extract n {
	0 => s,
	1 => s >> (id <> rx),
	2 => s >> (id <> rz),
	3 => s >> (id <> |a| rx(rz(a))),
}

fn decode(s) = measure(ibell(s))

let data = 2
let shared = encode(bell(F, F), data)

print ibell(shared)

assert data : decode(shared)

fn ry = {
	F => [50%] T,
	T => [150%] F,
}

fn rotate(r)(s) = extract r {
	X => rx(s),
	Y => ry(s),
	Z => rz(s),
}

print rotate(X ^ Z)(F)

; rotate(X ^ ~Y)(T)
