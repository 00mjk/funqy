data Bool = F | T
data Dir3 = X | Y | Z

let (abc, qwe) = ((F, T), T)

fn equal = {
	(F, F) | (T, T) => T,
	_ => F,
}

fn parallel = {
	(X, X) | (Y, Y) | (Z, Z) => T,
	_ => F,
}

let (@) = |s| sup(s)

fn (!) = {
	F => T,
	T => F,
}

assert @T : equal(T, T)
assert @T : !equal(F, T)

let (^) = sup
let (~) = phf

assert F ^ T : T ^ F
assert F ^ T : @(F ^ T)

fn had = {
	F => F ^ T,
	T => F ^ ~T,
}

fn cnot(a, b) = extract a {
	F => (F, b),
	T => (T, !b),
}

let (#) = had
let (*!) = cnot

fn bell(a, b) = #a *! b

print had(had(F))

bell(F, F)