data Bool = F | T
data Dir3 = X | Y | Z

let (abc, qwe) = ((F, T), T)

fn equal = {
	(F, F) | (T, T) => T,
	_ => F,
}

fn parallel = {
	(X, X) | (Y, Y) | (Z, Z) => T,
	_ => F,
}

fn (>>)(a, b) = b(a)
fn (<<)(a, b) = a(b)

fn (@)(s) = sup(s)
let (#) = measure

fn (!) = {
	F => T,
	T => F,
}

assert @T : equal(T, T)
assert @T : !equal(F, T)

let (^) = sup
let (~) = phf

assert F ^ T : T ^ F
assert F ^ T : @(F ^ T)

fn id = {
	F => F,
	T => T,
}

fn rz = {
	F => F,
	T => ~T,
}

fn had = {
	F => F ^ T,
	T => F ^ ~T,
}

fn cnot(a, b) = extract a {
	F => (F, b),
	T => (T, !b),
}

let (*!) = cnot

fn bellgate(a, b) = had(a) *! b

fn bell = {
	(F, F) => (F, F) ^ (T, T),
	(F, T) => (F, T) ^ (T, F),
	(T, F) => (F, F) ^ ~(T, T),
	(T, T) => (F, T) ^ ~(T, F),
}
fn ibell = {
	(F, F) => (F, F) ^ (T, F),
	(F, T) => (F, T) ^ (T, T),
	(T, F) => (F, T) ^ ~(T, T),
	(T, T) => (F, F) ^ ~(T, F),
}

assert @F : had(had(F))

fn kron(a, b) = |s| extract s {
	(F, F) => (a(F), b(F)),
	(F, T) => (a(F), b(T)),
	(T, F) => (a(T), b(F)),
	(T, T) => (a(T), b(T)),
}
let (<>) = kron

fn encode(s, n) = extract n {
	0 => s,
	1 => s >> (id <> (!)),
	2 => s >> (id <> rz),
	3 => s >> (id <> |a| !rz(a)),
}

fn decode(s) = measure(ibell(s))

let data = 1
let shared = encode(bell(F, F), data)

print ibell(shared)

decode(shared)