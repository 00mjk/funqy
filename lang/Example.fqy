### A few ideas for language syntax/semantics ###

### Key feature -- `extract` -- can account for simultaneous execution branches simultaneously ###

# (built-in) State datatype
data State<T> = Val(T) | Sup(State<T>, State<T>) | Phase(State<T>, Phase)

# (built-in) Phase datatype
data Phase = Left | Right

# Boolean datatype
data Bool = F | T

# Type alias for 2-dimensional (qubit) state using Boolean as possible values
type S2 = State<Boolean>


# State creation operator
(@)(a) = State.Val(a)

# Superposition operator
(^^)(a, b) = State.Sup(a, b)

# Phase shift operator
(~~)(a, p) = State.Phase(a, p)


# Boolean NOT state function (equivalent to Pauli-X gate)
not(s: S2): S2 = extract s
	F => @T,
	T => @F,

##	# Boolean Y state function (equivalent to Pauli-Y gate)
##	fy(s: S2): S2 = ...							# ???
##
##	# Boolean phase shift state function (equivalent to Pauli-Z gate)
##	fz(s: S2): S2 = ...							# ???

# Hadamard state function (equivalent to H gate)
had(s: S2): S2 = extract s
	F => @F ^^ @T,										# (|0> + |1>) / sqrt 2
	T => @F ^^ (@T ~~ Phase.Left),		# (|0> - |1>) / sqrt 2

# Controlled NOT state function (equivalent to CNOT gate)
cnot(a: S2, b: S2): (S2, S2) = extract a
	F => (a, b),
	T => (a, not(b)),

# Bell state function (equivalent to the circuit [H.I, CNOT])
bell(a: S2, b: S2): (S2, S2) {
	let ha = had(a)
	cnot(ha, b)
}

# Generic if/then/else state function
ifThenElse<T>(a: S2, b: State<T>, c: State<T>): State<T> = extract a
	T => b,
	F => c,

# Qutrit datatype / state type alias
data Axis3 = X | Y | Z
type S3 = State<Axis3>

# Return 1 if the values are aligned, 0 otherwise (or some combination)
# Note that this function takes 2 qutrit states and outputs a qubit state
compare(a: S3, b: S3): S2 = extract (a, b)
	(X, X) => @T,
	(Y, Y) => @T,
	(Z, Z) => @T,
	_ => @F,

# Convert from Bool state to Axis3 state in the X and Y dimensions
toAxis3(s: S2): S3 = extract s
	F => @X,
	T => @Y,
